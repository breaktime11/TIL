# [스프링 핵심원리] 객체 지향 설계와 스프링

> 김영한님의 스프링 핵심 원리 - 기본편 강의를 듣고 스프링을 다시 차근차근 공부한 기록
>
> 왜 스프링을 사용하고, 왜 스프링이 그 기능을 제공하는지 등을 중점으로 스프링을 제대로 이해하는 것이 목표
>
> <br>
>
> ### 목차
>
> 1. 객체 지향 설계와 스프링
>2. 스프링 핵심 원리 이해1 - 예제 만들기
> 3. 스프링 핵심 원리 이해2 - 객체 지향 원리 적용
> 4. 스프링 컨테이너와 스프링 빈
> 5. 싱글톤 컨테이너
> 6. 컴포넌트 스캔
> 7. 의존관계 자동 주입
> 8. 빈 생명주기 콜백
> 9. 빈 스코프
> 10. 다음으로

# [1] 스프링
## 1. 스프링의 탄생

2000년대 초반에는 자바 진영의 표준 기술인 EJB(Enterprise Java Beans)로 서버를 만들었다. 하지만 EJB는 저어엉말 복잡하고 어렵고 느렸기 때문에 당시 개발자들은 EJB 지옥에서 허덕이고 있었다. 😱😱😱그 때 구세주 처럼 로드 존슨, 두 명의 개발자가 등장했다. 

로드 존슨은 EJB를 비판하며 EJB보다 훨씬 단순하면서 더 좋은 방법을 제시했고, 이것이 스프링의 시초가 되었다. 게빈 킹은 EJB의 엔티티빈을 비판하며 오픈소스 Hibernate를 만들었다. 이 Hibernate를 바탕으로 자바 표준 인터페이스인 JPA가 탄생했다. 

<br>

### 스프링 역사

출처 http://www.yes24.com/Product/Goods/428809

![expert one-on-one J2EE 설계와 개발 - YES24](https://image.yes24.com/Goods/428809/L)

- 2002년 로드 존슨의 책 출간
- EJB의 문제점을 지적하면서 EJB 없이 고품질의 애플리케이션을 개발할 수 있다고 말하며 현재 스프링의 기반이 되는 3만 라인 이상의 예제 코드를 선보였다.
- 로드 존슨의 책에 사람들이 열광했던 이유는 EJB에 종속된 개발이 객체 지향이 가진 좋은 장점을 살릴 수 없었기 때문이다.
- 이 책이 딱 출간되고 나서 유겐 휠러, 얀 카로프가 로드 존슨에게 오픈소스 프로젝트를 제안했다. 이후 천재 개발자 유겐 휠러가 스프링의 핵심 코드 상당수를 개발했다고 한다.
- 스프링의 이름은 지옥같은 EJB를 넘어 새로운 봄같은 시작이라는 뜻에서 붙여졌다고 한다.

<br>

### 릴리즈 역사

- 2003 스프링 프레임워크 1.0 출시 - XML
- 2006 스프링 프레임워크 2.0 출시 - XML 편의 기능 지원
- 2009 스프링 프레임워크 3.0 출시 - 자바 코드 설정
- 2013 스프링 프레임워크 4.0 출시 -  자바8
- 2014 스프링 부트 1.0 출시
  - 스프링부트의 출시!
    - 스프링 프레임워크로 개발시 설정의 번거로움을 해결하기 위해 나왔다.
    - 기존에 스프링 프레임워크로 플젝할 때 톰캣 웹서버 세팅하고 그러는게 증말증말 번거로웠던 기억이 있다.🤮
- 2017 스프링 프레임워크 5.0, 스프링 부트 2.0 출시 - 리액티브 프로그래밍 지원
  - 비동기 지원
- 현재 스프링 프레임워크 5.2.x, 스프링 부트 2.3.x

<br>

<br>

## 2. 스프링이란?

### 스프링 생태계

스프링은 여러가지 기술의 모음이라고 볼 수 있다.

- 스프링 프레임워크, 스프링 부트
- 스프링 데이터, 스프링 시큐리티, 스프링 클라우드 등..

<br>

### 스프링 프레임워크

아래의 기술들을 통합해서 스프링 프레임워크라고 부른다.

- **핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타**
- 웹 기술 : 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술 : 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합 : 캐시, 이메일, 원격 접근, 스케줄링
- 테스트 : 스프링 기반 테스트 지원
- 언어 : 코틀린, 그루비

<br>

### 스프링 부트

최근에는 스프링을 편리하게 사용하도록 지원해주는 스프링부트를 많이 사용한다.

#### 스프링부트의 장점

- Tomcat과 같은 **웹 서버를 내장**하여 별도의 웹 서버를 설치하지 않아도 되기 때문에
- 단독으로 실행할 수 있는 스프링 애플리케이션을 **쉽게 생성**할 수 있게 도와준다
  - *이전에는* 애플리케이션을 한번 빌드하고 톰캣 서버를 별도로 설치하고 띄우는 등... 웹 서버 구동 과정이 매우 복잡했다. 스프링 부트의 내장 웹 서버는 이러한 번거로운 과정을 단순화 시켜줬다.
- **손쉬운 빌드 구성**을 위한 **starter 종속성** 제공
  - *이전에는* 스프링 프레임워크 사용을 위해 필요한 라이브러리 등을 각각 설정해줘야했다. 스프링 부트는 jpa-starter와 같은 starter를 통해 관련된 라이브러리를 한꺼번에 편리하게 가져와준다.
- 스프링과 **3rd party(외부) 라이브러리 자동 구성**
  - *이전에는* 스프링 3 버전과 외부 라이브러리 버전이 안 맞는 등 버전 관리가 매우 까다로웠다. 스프링 부트는 스프링과 외부 라이브러리의 버전을 자동으로 매칭시켜준다.
- 매트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
  - 운영 환경의 모니터링에 필요한 기능 제공
- 관례에 의한 간결한 설정
  - *이전에는* 설정이 매우 귀찮았다. 스프링 부트는 웬만한 것은 디폴트 설정이 지정되어있다. 꼭 필요한 부분만 커스텀하면 된다.

<br>

### 스프링이란 단어?

스프링이라는 단어 스프링 부트, 스프링 프레임워크를 모~두 포함한 스프링 생태계를 의미한다.

<br>

<br>

## 3. 스프링은 왜 만들었을까?

### 스프링의 핵심 개념, 컨셉은?

자바 언어의 가장 큰 특징은 객체 지향 언어라는 점이다. 스프링은 이러한 자바 언어 기반의 프레임워크이며 객체 지향 언어가 가진 특징을 잘 살려내는 프레임워크이다.

즉, 스프링은 **좋은 객체 지향 애플리케이션을 개발**할 수 있게 도와주는 프레임워크이다.

이걸 가능하게 도와주는 도구는 스프링이 가진 **DI 컨테이너**(IoC 컨테이너)이다.

<br>

<br>

# [2] 좋은 객체 지향 프로그래밍

## 1. 객체 지향 프로그래밍이란

객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "**객체"들의 모임**으로 파악하는 것이다. 각각의 객체는 메시지를 주고 받고, 데이터를 처리할 수 있다. (**협력**)

객체 지향 프로그래밍은 프로그램을 **유연**하고 **변경이 용이**하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다. -> **다형성**!

<br>

### 절차지향 프로그래밍 VS 객체 지향 프로그래밍

- **절차 지향 프로그래밍**
  - **순차적**인 처리가 중요시 되는 프로그래밍 기법
  - **데이터의 처리 방법**에 초점을 둠
    - Flow Chart를 짜는 것을 우선순위에 둔다
  - 컴퓨터가 사고하는 대로 프로그래밍
  - 대표 언어 : C언어
  - 장점
    - 코드의 실행 속도가 빠르다
  - 단점
    - 한번 사용한 코드를 재사용하기 어렵다
    - 유지보수가 어렵고
    - 대형 프로젝트를 할 때 코드가 몇 십, 몇 백배로 늘어남
- **객체 지향 프로그래밍**
  - **현실 세계**의 사물들을 **객체로 모델링**하여 개발을 진행하는 프로그래밍 기법
  - **데이터 그 자체**에 초점을 둠
    - Data Modeling을 우선순위에 둔다
  - 왜 나오게 됐을까?
    - 소프트웨어의 발전 속도를 하드웨어가 따라오지 못해서
      - 개발하려는 데이터들을 **기능별로 묶어 모듈화**
      - 하드웨어가 같은 기능을 **중복 연산하지 않도록** 하고
      - **모듈을 재활용**하여 하드웨어 처리량을 획기적으로 줄임
  - 장점
    - 코드의 재활용이 가능하다 (상속)
    - 코딩이 간단하다 (캡슐화)
    - 유지보수 및 업그레이드 용이 (다형성)

<br>

### 객체 지향의 4대 특징

- **추상화**
  - 사물들의 공통적인 특징이나 속성을 파악해 이를 하나의 개념(집합)으로 다룬 것
    - 클래스 : 데이터를 만들기 위한 추상화를 거쳐, 집단에 속하는 속성(attribute)과 행위(behavior)를 변수와 메소드로 정의한 것
    - 인스턴스 (객체) : 클래스에서 정의한 것을 토대로 메모리상에 할당된 실제 데이터
- **캡슐화 (Encapsulation)**
  - 필요한 데이터들을 하나의 묶음, 즉 캡슐에 넣듯이 처리
  - 데이터는 은닉화(Private), 메소드(public)를 통해 외부와 소통이 가능
- **상속 (Extends)**
  - 이미 작성된 클래스(부모 클래스)를 이어받아서 새로운 자식 클래스를 작성
  - 기존 코드를 재활용
- **다형성** (Polymorphism)
  - 하나의 이름(메소드, 방법)으로 많은 상황을 대체할 수 있는 기법
    - Overriding : 상속 관계에서 부모 클래스의 속성을 재사용
    - Overloading : 같은 이름의 함수를 사용하면서 매개변수의 종류를 다르기 선언

<br>

<br>

## 2. 다형성

![img](https://media.vlpt.us/images/happykimnh/post/70e5c56f-00a4-474f-a89d-3c40d39c8522/image.png)

### 다형성을 실세계 비유하자면

- **역할**과 **구현**으로 세상을 구분
  - 운전자 역할, 자동차 역할 / K3, 아반떼 자동차 구현
  - 정렬 알고리즘 등
- 자동차가 바뀌어도 운전자에게 영향을 안준다. -> **유연하고 변경에 용이하다**!
  - 운전자는 자동차의 역할(인터페이스)에만 의존하기 때문이다.
  - 운전자를 위해 자동차의 역할과 구현을 분리한 것이다.
    - 운전자는 자동차의 내부 모습을 알 필요가 없다.
    - 자동차를 다른 대상으로 변환이 가능하며 심지어 새로운 자동차가 나와도 운전자에게는 어떠한 영향을 주지 않기 때문에 자동차의 세상을 **무한 확장**할 수 있다.

<br>

### 역할과 구현으로 세상을 분리

- **역할**과 **구현**으로 구분하면 세상이 **단순**해지고, **유연**해지며 **변경도 편리**해진다.
- **클라이언트에 영향을 주지 않고** **새로운 기능을 구현할 수 있다**.
- 장점
  - 프로그램을 유연하고 변경에 용이하며 무한으로 확장 가능하게 설계 할 수 있다.
    - 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
    - 클라이언트는 구현 대상의 **내부 구조를 몰라**도 된다.
    - 클라이언트는 구현 대상의 **내부 구조가 변경되어도** 영향을 받지 않는다.
    - 클라이언트는 구현 **대상 자체를 변경**해도 영향을 받지 않는다.
- 인터페이스를 안정적으로 잘 설계하는 것이 중요

<br>

### 자바 언어의 다형성

- 실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음
- 자바 언어의 **다형성**
  - **역할** = **인터페이스**
  - **구현** = **인터페이스를 구현한 클래스, 구현 객체**
- 객체를 설계할 때 역할과 구현을 명확히 분리
- 객체 설계시 역할(인터페이스)를 먼저 부여하고, 그 역할을 수행하는 구현 객체를 만들기
- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 **유연하게 변경**할 수 있다.
- 다형성의 본질을 이해하기 위해서는 협력이라는 객체 사이의 관계를 이해해야함
  - 객체의 협력?
    - 혼자 있는 객체는 없다.
    - 클라이언트 : **요청**, 서버 : **응답**
    - 수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다.
- **클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.**

<br>

### 한계

- 역할(인터페이스) 자체가 변하면 클라이언트, 서버 모두에 큰 변경이 발생한다.
  - 자동차가 비행기로.. 변경되면 🤬
- **인터페이스를 안정적으로 잘 설계하는 것이 중요**
  - 가장 변화가 없는 방식으로 설계!

<br>

### 스프링과 객체지향

- 다형성은 객체 지향에 있어 아주 중요한 개념이다.
- 스프링은 **다형성을 극대화하여 이용**할 수 있게 도와준다.
- 스프링에서 이야기하는 **제어의 역전(IoC)**, **의존 관계 주입(DI)**는 **다형성**을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.
- 스프링을 사용하면 마치 레고 블록 조립하듯이! 공연 무대의 배우를 선택하듯이! **구현을 편리하게 변경**할 수 있다.

<br>

<br>

## 3. 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

> 클린코드로 유명한 로버트 마틴의 좋은 객체 지향 설계의 5가지 원칙
>
> 1. SRP : 단일 책임 원칙 (Single Responsibility Principle)
> 2. OCP : 개방 - 폐쇄 원칙 (Open - Closed Principle)
> 3. LSP : 리스코프 치환 원칙 (Liskov Substitution Principle)
> 4. ISP : 인터페이스 분리 원칙 (Interface Segregation Principle)
> 5. DIP : 의존관계 역전 원칙 (Dependency Inversion Principle)

출처 https://codeburst.io/solid-design-principle-using-swift-fa67443672b8

![SOLID Principles | Blog](https://amitshahi.dev/static/500403c0fabdd69504307a79a5417fd9/be90f/solid.jpg)

### (1) SRP 단일 책임 원칙 (Single Responsibility Principle)

- 하나의 클래스는 하나의 책임만 가져야 한다
- 중요한 판단 기준은 **변경**이다.
  - 변경이 있을 때 **파급 효과가 적으면**, 단일 책임 원칙을 잘 따른 것
    - 변경이 있을 때 딱 하나의 클래스의 변경된 부분만 고칠 수 있으면 잘 따른 것 ex) UI 변경

<br>

### (2) OCP 개방-폐쇄 원칙 (Open - Closed Principle)

- 소프트웨어 요소는 **확장에는 열려**있으나, **변경에는 닫혀**있어야 한다.
- **다형성**을 잘 활용하면 개방 폐쇄 원칙을 지킬 수 있다.
  - 인터페이스를 구현한 새로운 클래스를 하나 더 만들면 새로운 기능 구현이 가능하다 (확장에 열려있음)
- 만약 다형성을 사용했음에도 불구하고 OCP 원칙을 지킬 수 없는 경우가 있다면.. ex) 구현 객체를 변경하려고 클라이언트 코드를 변경해야할 경우
  - 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
    - 즉, 스프링의 컨테이너가 필요하다.

<Br>

### (3) LSP 리스코프 치환 원칙 (Liskov Substitution Principle)

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- **다형성**에서 **하위 클래스**는 **인터페이스 규약**을 정확히 지켜야 한다
  - 어떤 인터페이스가 있을 때 그 규약을 무조건 맞춰야 한다. 기능적으로 그 규약을 보장해줘야한다.
    - ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능인데 만약 뒤로 가게 구현하면 LSP를 위반하게 된다.
- 인터페이스를 구현한 구현체를 믿고 사용하기 위해서는 LSP 원칙이 필요하다.

<br>

### (4) ISP 인터페이스 분리 원칙 (Interface Segregation Principle)

- **특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다**
  - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
  - 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리 가능하다
    - 이렇게 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.

<br>

### (5) DIP 의존관계 역전 원칙 (Dependency Inversion Principle)

- 프로그래머는 "*추상화에 의존해야지, 구체화에 의존하면 안된다*". 의존성 주입은 이 원칙을 따르는 방법 중 하나
- 클라이언트 코드가 구현 클래스에 의존하지 말고, **인터페이스에 의존**하라는 뜻
- 앞의 **역할(Role)에 의존하게 해야 한다**는 것과 같다.
  - 객체에서는 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.
    - 구현 클래스를 직접 선택해야하는 경우에 DIP 위반
    - ㅠㅠ 구현체가 없이 어캐 코드가 돌아가나여..T.T

<br>

<br>

## 4. 객체지향 설계와 스프링

> - 객체 지향의 핵심은 다형성!
> - 하지만 다형성 만으로는 OCP, DIP를 지킬 수 없다
>   - 클라이언트의 코드를 자꾸 변경하게된다.
> - 뭔가 더 필요합니다.. 클라이언트 코드 변경을 막을수 없숩니다.. -> 스프링

스프링은 DI, DI 컨테이너의 제공으로 **다형성과 OCP, DIP를 가능하게 지원해준다.**

- DI (Dependency Injection) : 의존 관계, 의존성 주입
- DI 컨테이너 제공
  - 자바의 객체들을 컨테이너에 넣어놓고, 이 안에서 의존 과계를 서로 연결해주고 주입해준다.

위의 기술들을 활용하면 **클라이언트의 코드 변경 없이 기능을 확장**할 수 있다.

<br>

### 정리

- 모든 설계에 **역할**과 **구현**을 분리하자
- **구현 부분을 언제든지 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계다.**
  - 이것을 위해 다형성, OCP, DIP 등을 다 지켜야하는데, 스프링 컨테이너가 이를 가능하게 도와준다.
  - 즉, 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와준다.
- 이상적으로 모든 설계에 **인터페이스를 부여**하자
  - 구현 기술이 바뀌더라도 나머지를 바꿀 필요 없기 때문에 변경의 범위가 굉장히 작고 유연해진다는 장점이 있다.
- BUT 인터페이스를 무분별하게 도입하면 추상화라는 비용이 발생한다.
  - 높은 추상화 수준으로 올라갈수록 상세한 사항은 은폐된다. 따라서 개발자는 코드를 한 번더 구현 클래스를 열어봐야하는 상황이 발생한다